根据我目前的理解，一个3D渲染引擎的材质需要定义下面这些元素：
1. 混合模式
决定了几何对象渲染完成后如何与场景中的其他物体进行叠加，由于某些混合模式的特性，它会影响了对象的绘制顺序，混合模式的渲染次序从先到后是：
不透明（Opaque） > 蒙版（Masked） > 半透明（Translucent） > 叠加（Additive） > Modulate(不知道怎么翻译，乘法混合？)

2. 着色模型
我的理解就是一对或多对顶点与像素着色器的组合（Pass），决定了材质的参数与光照参数如何被处理，从而合成最终的色彩。比如最基本的着色模型如下：
Surface Color = Emissive + Ambient + Diffuse + Specular

3. 其他渲染状态（Render State）
比如剔除模式（正面、背面 or 不剔除）等

4. 根据着色模型中的每个Pass定义的参数（Shader中使用到的Uniform参数）
比如纹理贴图（不仅是色彩，还可以是法线贴图、凹凸贴图、环境贴图等等）、光照参数、Pass间的混合参数等等

此外，通过对几何对象的材质进行分组排序，可以尽量减少渲染流程中的状态切换，从而达到提高渲染效率的目的，分组的顺序如下：
首先按混合模式分组，顺序如上面提到的：不透明混合 > 蒙版混合 > 半透明混合 > 叠加混合 > Modulate Blend；
混合模式分组后，每组中的对象再按着色模型分组；
着色模型分组后，每组对象再按纹理分组；
纹理分组后，……

即分组的优先级为：混合模式 > 着色模型 > 纹理对象 > 其他参数

【关于Technique】
1. Technique的作用 ：提高图形引擎的兼容性，低配机器一套technique，高配机器一套technique，主要分两种情况：
	A. 低配机器与高配机器实现相同的效果，旧版本显卡由于对Uniform数量的支持不够或纹理数量支持不够，需要使用更多的pass
	B. 低配机器上实现更简单的效果，高配机器上实现高级效果
2. OGRE将Technique与材质的定义耦合在一起，每个材质需要为不同的Technique定义参数

【关于Uniform】
1. 诺亚现在的实现方式是不同的Uniform都从同一个Uniform基类中派生出来，着色器（FX）类中不定义特定的Uniform，而是定义一个Uniform的map，设置参数
   时需要遍历这个map，根据VTune的性能检测结果，SetUniform是一个热点函数，而它40%的时间都用在了创建map的迭代器上。
2. OGRE中也有类似的实现，但它使用了一个链表存储Uniform而不是map，遍历的效率高了很多，但降低了查找效率